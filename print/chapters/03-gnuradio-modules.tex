GNURadio \cite{gnuradioweb} is a set of free software \cite{fsffreeweb}
tools that are useful for building and simulating radio systems.
This chapter presents the anatomy of a GNURadio module.

\begin{subchapter}{GNURadio Companion}
  The first point of contact for most new GNURadio users
  is usually the \gls{grc}, a program that lets
  users design signal flowgraphs in a graphical way.
  \Gls{grc}'s main interface is shown in figure
  \ref{img:annotated_gnuradio_companion}, the flowgraph
  is an implementation of the \acrlong{schcox} detector block-diagram
  shown in figure \ref{img:sc_detector_blocks} in the previous
  chapter.

  \figurizefile{diagrams/annotated_gnuradio_companion.tex}
               {img:annotated_gnuradio_companion}
               {The \acrlong{grc}}
               {1}{ht}

  When a flowgraph containing graphical instrumentation like
  the \texttt{QT GUI Time Sink} in figure \ref{img:annotated_gnuradio_companion}
  is executed, a window will open containing the output of
  the instruments.

  Figure \ref{img:gnuradio_gui} shows such a window, containing
  a \texttt{QT GUI Time Sink}, a GNURadio oscilloscope.

  \figurizegraphic{images/gnuradio_gui.png}
                  {img:gnuradio_gui}
                  {The graphical output of a running flowgraph}
                  {0.8}{ht}

  \Gls{grc} works by generating a Python script from the
  graphical flowgraph representation, based on predefined
  patterns.

  A minimal flowgraph like the one shown in figure
  \ref{img:gnuradio_companion_minimal}, is translated
  to a Python script much like the one shown in
  listing \ref{lst:gnuradio_companion_minimal}
  (the code in the listing was edited for brevity
  as the autogenerated code is usually more verbose).

  When an user selects the \texttt{run} option in \gls{grc}
  the script will automatically be generated and executed,
  so that the user does not have to deal with any Python
  code while experimenting.

  \figurizegraphic{images/gnuradio_companion_minimal.png}
                  {img:gnuradio_companion_minimal}
                  {A minimal \gls{grc} flowgraph}
                  {0.6}{H}
\end{subchapter}

\begin{subchapter}{GNURadio native programming interfaces}
  While \gls{grc} is a great tool to experiment with signals,
  filters and prebuilt decoders, more advanced processing will
  often require writing processing blocks in, more flexible,
  textual programming languages.

  GNURadio provides two native interfaces to write own
  blocks in, C++ and Python 2\footnote{There is some work done
  in supporting Python 3, but as of the time of writing there is no
  mainline support for it.}.
  The Python interface has the benefit of being easier to program
  for while the C++ will usually provide better processing performance,
  as the code using it is compiled to native processor instructions.
  These tradeoffs should be considered when writing a
  new GNURadio processing block.

  \begin{subsubchapter}{Python-interface}
    Listing \ref{lst:gnuradio_companion_minimal} shows a block written
    in Python that does not perform its own signal processing but
    instead connects other blocks to produce a processing chain.

    The block is derived from the \texttt{gr.top\_block} base class,
    as can be seen in line \texttt{5}. Blocks derived from this base class
    do not expose any input or output ports and do not perform their own
    signal processing, instead they are used to hierarchically connect
    other blocks to form a graph.
    A typical GNURadio program will contain one top block that is
    used to connect the signal processing chain.

    There are also some other base classes from which GNURadio
    blocks can be derived\cite{grblockscodingguide}:

    \begin{description}
      \item[\texttt{gr.sync\_block}]
        A block that, for every input item, will produce exactly
        one output item. This can, for example, be a block that,
        for a stream of complex input symbols, outputs the real
        magnitude of each symbol.

        Or the multiply block, as seen in figure
        \ref{img:gnuradio_companion_minimal}, which will produce one
        output symbol for each input symbol present at both inputs.

      \item[\texttt{gr.sync\_decimator}]
        Decimator blocks are quite similar to sync blocks,
        but will produce output items at lower rate than input items
        are consumed.

        The relative input and output rate has to be fixed.

        One example would be a block that takes two consecutive input
        items, adds them and outputs them as a single output item.

        Decimator blocks are especially useful for
        sample rate reducing filters.

      \item[\texttt{gr.sync\_interpolator}]
        Interpolator blocks are the rate-increasing pendant
        to decimator blocks.

      \item[\texttt{gr.block}]
        \texttt{Gr.block} is the base class for every other class
        in this list, as it is the most generic block type.

        Thise base class does not impose any rate restrictions
        on the block, allowing for greater flexibility when
        programming a block derived from this base class.

        There is however some more housekeeping work to be
        done that can no longer be handled automatically when
        choosing this block instead of the more restricted base classes,
        to keep the processing efficient.

      \item[\texttt{gr.hier\_block2}]
        Blocks derived from this base class are pureley
        hierarchical, they do not perform any signal processing
        themselve but instead combine other blocks to perform
        signal processing on the hierarchical block's inputs and
        output the results on the hierarchical block's outputs.

      \item[\texttt{gr.top\_block}]
        The top block, as discussed earlier, is a special kind of
        hierarchical block that does not provide any inputs or outputs.

        Instead it contains some additional functionality to execute
        the contained flowgraph.
    \end{description}

    \begin{minipage}{\linewidth}
      \lstinputlisting[numbers=left, basicstyle=\scriptsize,
                       numbersep=5pt, language=Python,
                       caption=Using GNURadio from Python,
                       label=lst:gnuradio_companion_minimal,
                       captionpos=b]
                      {listings/gnuradio_companion_minimal.py}
    \end{minipage}
  \end{subsubchapter}

  \begin{subsubchapter}{C++-Interface}
    \begin{minipage}{\linewidth}
      \lstinputlisting[numbers=left, basicstyle=\scriptsize,
                       numbersep=5pt, language=C++,
                       caption=A simple custom block in C++,
                       label=lst:square.cc,
                       captionpos=b]
                      {listings/square.cc}
    \end{minipage}
  \end{subsubchapter}
\end{subchapter}


\begin{subchapter}{GNURadio Internals}
\end{subchapter}
